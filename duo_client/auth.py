"""
Duo Security Auth API reference client implementation.

<http://www.duosecurity.com/docs/authapi>
"""
import client

def ping(ikey, skey, host, ca=None):
    """
    Determine if the Duo service is up and responding.

    Returns information about the Duo service state: {
        'time': <int:UNIX timestamp>,
    }
    """
    path = '/auth/v2/ping'
    return client.call_json_api(ikey, skey, host, 'GET', path, ca)


def check(ikey, skey, host, ca=None):
    """
    Determine if the integration key, secret key, and signature
    generation are valid.

    Returns information about the Duo service state: {
        'time': <int:UNIX timestamp>,
    }
    """
    path = '/auth/v2/check'
    return client.call_json_api(ikey, skey, host, 'GET', path, ca)

def enroll(ikey, skey, host, username=None, valid_secs=None,
           ca=None):
    """
    Create a new user and associated numberless phone.

    Returns activation information: {
        'activation_barcode': <str:url>,
        'activation_code': <str:actcode>,
        'user_id': <str:autogenerated>,
        'username': <str:provided or autogenerated>,
        'valid_secs': <int:seconds>,
    }
    """
    path = '/auth/v2/enroll'
    kwargs = {}
    if username is not None:
        kwargs['username'] = username
    if valid_secs is not None:
        valid_secs = str(int(valid_secs))
        kwargs['valid_secs'] = valid_secs
    return client.call_json_api(ikey, skey, host, 'POST', path, ca,
                                **kwargs)

def enroll_status(ikey, skey, host, user_id, activation_code, ca=None):
    """
    Check if a user has been enrolled yet.

    Returns a string constant indicating whether the user has been
    enrolled or the code remains unclaimed.
    """
    path = '/auth/v2/enroll_status'
    response = client.call_json_api(ikey, skey, host, 'POST', path, ca,
                                    user_id=user_id,
                                    activation_code=activation_code)
    return response

def bypass_codes(ikey, skey, host,
                 username=None,
                 user_id=None,
                 count=None,
                 valid_secs=None,
                 ca=None):
    """
    Generate bypass codes for the user, invalidating any existing codes.

    Returns an expiration time and the list of codes: {
        'codes': [ <str:code>, ... ],
        'expiration': <int:UNIX timestamp>,
    }
    """
    path = '/auth/v2/bypass_codes'
    kwargs = {}
    if username is not None:
        kwargs['username'] = username
    if user_id is not None:
        kwargs['user_id'] = user_id
    if count is not None:
        count = str(int(count))
        kwargs['count'] = count
    if valid_secs is not None:
        valid_secs = str(int(valid_secs))
        kwargs['valid_secs'] = valid_secs
    response = client.call_json_api(ikey, skey, host, 'POST', path, ca,
                                    **kwargs)
    return response

def preauth(ikey, skey, host, username=None, user_id=None, ca=None):
    """
    Determine if and with what factors a user may authenticate or enroll.
    """
    path = '/auth/v2/preauth'
    kwargs = {}
    if username is not None:
        kwargs['username'] = username
    if user_id is not None:
        kwargs['user_id'] = user_id
    response = client.call_json_api(ikey, skey, host, 'POST', path, ca,
                                    **kwargs)
    return response

def auth(ikey, skey, host,
         factor,
         username=None,
         user_id=None,
         ipaddr=None,
         async=False,
         type=None,
         display_username=None,
         pushinfo=None,
         device=None,
         passcode=None,
         ca=None):
    """
    Perform second-factor authentication for a user.

    If async is True, returns: {
        'txid': <str: transaction ID for use with auth_status>,
    }

    Otherwise, returns: {
        'result': <str:allow|deny>,
        'status': <str:machine-parsable>,
        'status_msg': <str:human-readable>,
    }
    """
    path = '/auth/v2/auth'
    kwargs = {
        'async': str(int(bool(async))),
    }
    if username is not None:
        kwargs['username'] = username
    if user_id is not None:
        kwargs['user_id'] = user_id
    if ipaddr is not None:
        kwargs['ipaddr'] = ipaddr
    if type is not None:
        kwargs['type'] = type
    if display_username is not None:
        kwargs['display_username'] = display_username
    if pushinfo is not None:
        kwargs['pushinfo'] = pushinfo
    if device is not None:
        kwargs['device'] = device
    if passcode is not None:
        kwargs['passcode'] = passcode
    response = client.call_json_api(ikey, skey, host, 'POST', path, ca,
                                    factor=factor,
                                    **kwargs)
    return response

def auth_status(ikey, skey, host, txid, ca=None):
    """
    "Longpoll" for the status of an asynchronous authentication call.

    Returns a tuple with four named fields:

    * waiting: True if the authentication attempt is still in progress
      and the caller can continue to poll, else False.

    * success: True if the authentication request has completed and
      was a success, else False.

    * status: String constant identifying the request's state.

    * status_msg: Human-readable string describing the request state.
    """
    path = '/auth/v2/auth_status'
    kwargs = {}
    response = client.call_json_api(ikey, skey, host, 'GET', path, ca,
                                    txid=txid)
    return {
        'waiting': (response.get('result') == 'waiting'),
        'success': (response.get('result') == 'allow'),
        'status': response.get('status', ''),
        'status_msg': response.get('status_msg', ''),
    }
